// Code generated by protoc-gen-go.
// source: libri/librarian/api/documents.proto
// DO NOT EDIT!

/*
Package api is a generated protocol buffer package.

It is generated from these files:
	libri/librarian/api/documents.proto
	libri/librarian/api/librarian.proto

It has these top-level messages:
	Document
	Envelope
	Entry
	Metadata
	PageKeys
	Page
	RequestMetadata
	ResponseMetadata
	PingRequest
	PingResponse
	IntroduceRequest
	IntroduceResponse
	FindRequest
	FindResponse
	PeerAddress
	StoreRequest
	StoreResponse
	GetRequest
	GetResponse
	PutRequest
	PutResponse
	SubscribeRequest
	SubscribeResponse
	Publication
	Subscription
	BloomFilter
*/
package api

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Document contains either an Envelope, Entry, or Page message.
type Document struct {
	// Types that are valid to be assigned to Contents:
	//	*Document_Envelope
	//	*Document_Entry
	//	*Document_Page
	Contents isDocument_Contents `protobuf_oneof:"contents"`
}

func (m *Document) Reset()                    { *m = Document{} }
func (m *Document) String() string            { return proto.CompactTextString(m) }
func (*Document) ProtoMessage()               {}
func (*Document) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type isDocument_Contents interface {
	isDocument_Contents()
}

type Document_Envelope struct {
	Envelope *Envelope `protobuf:"bytes,1,opt,name=envelope,oneof"`
}
type Document_Entry struct {
	Entry *Entry `protobuf:"bytes,2,opt,name=entry,oneof"`
}
type Document_Page struct {
	Page *Page `protobuf:"bytes,3,opt,name=page,oneof"`
}

func (*Document_Envelope) isDocument_Contents() {}
func (*Document_Entry) isDocument_Contents()    {}
func (*Document_Page) isDocument_Contents()     {}

func (m *Document) GetContents() isDocument_Contents {
	if m != nil {
		return m.Contents
	}
	return nil
}

func (m *Document) GetEnvelope() *Envelope {
	if x, ok := m.GetContents().(*Document_Envelope); ok {
		return x.Envelope
	}
	return nil
}

func (m *Document) GetEntry() *Entry {
	if x, ok := m.GetContents().(*Document_Entry); ok {
		return x.Entry
	}
	return nil
}

func (m *Document) GetPage() *Page {
	if x, ok := m.GetContents().(*Document_Page); ok {
		return x.Page
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Document) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Document_OneofMarshaler, _Document_OneofUnmarshaler, _Document_OneofSizer, []interface{}{
		(*Document_Envelope)(nil),
		(*Document_Entry)(nil),
		(*Document_Page)(nil),
	}
}

func _Document_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Document)
	// contents
	switch x := m.Contents.(type) {
	case *Document_Envelope:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Envelope); err != nil {
			return err
		}
	case *Document_Entry:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Entry); err != nil {
			return err
		}
	case *Document_Page:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Page); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Document.Contents has unexpected type %T", x)
	}
	return nil
}

func _Document_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Document)
	switch tag {
	case 1: // contents.envelope
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Envelope)
		err := b.DecodeMessage(msg)
		m.Contents = &Document_Envelope{msg}
		return true, err
	case 2: // contents.entry
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Entry)
		err := b.DecodeMessage(msg)
		m.Contents = &Document_Entry{msg}
		return true, err
	case 3: // contents.page
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Page)
		err := b.DecodeMessage(msg)
		m.Contents = &Document_Page{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Document_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Document)
	// contents
	switch x := m.Contents.(type) {
	case *Document_Envelope:
		s := proto.Size(x.Envelope)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Document_Entry:
		s := proto.Size(x.Entry)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Document_Page:
		s := proto.Size(x.Page)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Envelope defines the public keys an author uses to share an entry encryption key with a
// particular reader. The shared ECDH secret is used with a key derivation function to generate the
// entry encryption keys (EEK) for the given Entry. The EEK contains 4 sub-keys:
// 1) 32-byte AES-256 key, used to enrypt Pages and Entry metadata
// 2) 32-byte Page initialization vector (IV) seed
// 3) 32-byte HMAC-256 key
// 4) 12-byte metadata block cipher initialization vector
type Envelope struct {
	// 32-byte key of the Entry whose encryption keys are being sent
	EntryKey []byte `protobuf:"bytes,1,opt,name=entry_key,json=entryKey,proto3" json:"entry_key,omitempty"`
	// ECDH public key of the entry author/sender
	AuthorPublicKey []byte `protobuf:"bytes,2,opt,name=author_public_key,json=authorPublicKey,proto3" json:"author_public_key,omitempty"`
	// ECDH public key of the entry reader/recipient
	ReaderPublicKey []byte `protobuf:"bytes,3,opt,name=reader_public_key,json=readerPublicKey,proto3" json:"reader_public_key,omitempty"`
}

func (m *Envelope) Reset()                    { *m = Envelope{} }
func (m *Envelope) String() string            { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()               {}
func (*Envelope) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Envelope) GetEntryKey() []byte {
	if m != nil {
		return m.EntryKey
	}
	return nil
}

func (m *Envelope) GetAuthorPublicKey() []byte {
	if m != nil {
		return m.AuthorPublicKey
	}
	return nil
}

func (m *Envelope) GetReaderPublicKey() []byte {
	if m != nil {
		return m.ReaderPublicKey
	}
	return nil
}

// Entry is the main unit of storage in the Libri network.
type Entry struct {
	// ECDSA public key of the entry author
	AuthorPublicKey []byte `protobuf:"bytes,1,opt,name=author_public_key,json=authorPublicKey,proto3" json:"author_public_key,omitempty"`
	// contents of the entry, either a single Page or a list of page keys
	//
	// Types that are valid to be assigned to Contents:
	//	*Entry_Page
	//	*Entry_PageKeys
	Contents isEntry_Contents `protobuf_oneof:"contents"`
	// created epoch time (seconds since 1970-01-01)
	CreatedTime int64 `protobuf:"varint,4,opt,name=created_time,json=createdTime" json:"created_time,omitempty"`
	// ciphertext of marshalled Metadata message properties
	MetadataCiphertext []byte `protobuf:"bytes,5,opt,name=metadata_ciphertext,json=metadataCiphertext,proto3" json:"metadata_ciphertext,omitempty"`
	// 32-byte MAC of metatadata ciphertext, encrypted with the 32-byte Entry AES-256 key and
	// 12-byte metadata block cipher IV
	MetadataCiphertextMac []byte `protobuf:"bytes,6,opt,name=metadata_ciphertext_mac,json=metadataCiphertextMac,proto3" json:"metadata_ciphertext_mac,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type isEntry_Contents interface {
	isEntry_Contents()
}

type Entry_Page struct {
	Page *Page `protobuf:"bytes,2,opt,name=page,oneof"`
}
type Entry_PageKeys struct {
	PageKeys *PageKeys `protobuf:"bytes,3,opt,name=page_keys,json=pageKeys,oneof"`
}

func (*Entry_Page) isEntry_Contents()     {}
func (*Entry_PageKeys) isEntry_Contents() {}

func (m *Entry) GetContents() isEntry_Contents {
	if m != nil {
		return m.Contents
	}
	return nil
}

func (m *Entry) GetAuthorPublicKey() []byte {
	if m != nil {
		return m.AuthorPublicKey
	}
	return nil
}

func (m *Entry) GetPage() *Page {
	if x, ok := m.GetContents().(*Entry_Page); ok {
		return x.Page
	}
	return nil
}

func (m *Entry) GetPageKeys() *PageKeys {
	if x, ok := m.GetContents().(*Entry_PageKeys); ok {
		return x.PageKeys
	}
	return nil
}

func (m *Entry) GetCreatedTime() int64 {
	if m != nil {
		return m.CreatedTime
	}
	return 0
}

func (m *Entry) GetMetadataCiphertext() []byte {
	if m != nil {
		return m.MetadataCiphertext
	}
	return nil
}

func (m *Entry) GetMetadataCiphertextMac() []byte {
	if m != nil {
		return m.MetadataCiphertextMac
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Entry) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Entry_OneofMarshaler, _Entry_OneofUnmarshaler, _Entry_OneofSizer, []interface{}{
		(*Entry_Page)(nil),
		(*Entry_PageKeys)(nil),
	}
}

func _Entry_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Entry)
	// contents
	switch x := m.Contents.(type) {
	case *Entry_Page:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Page); err != nil {
			return err
		}
	case *Entry_PageKeys:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PageKeys); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Entry.Contents has unexpected type %T", x)
	}
	return nil
}

func _Entry_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Entry)
	switch tag {
	case 2: // contents.page
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Page)
		err := b.DecodeMessage(msg)
		m.Contents = &Entry_Page{msg}
		return true, err
	case 3: // contents.page_keys
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PageKeys)
		err := b.DecodeMessage(msg)
		m.Contents = &Entry_PageKeys{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Entry_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Entry)
	// contents
	switch x := m.Contents.(type) {
	case *Entry_Page:
		s := proto.Size(x.Page)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Entry_PageKeys:
		s := proto.Size(x.PageKeys)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Metadata is a map of (property, value) combinations.
type Metadata struct {
	Properties map[string][]byte `protobuf:"bytes,1,rep,name=properties" json:"properties,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Metadata) Reset()                    { *m = Metadata{} }
func (m *Metadata) String() string            { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()               {}
func (*Metadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Metadata) GetProperties() map[string][]byte {
	if m != nil {
		return m.Properties
	}
	return nil
}

// PageKeys is an ordered list of keys to Page documents that comprise an Entry document.
type PageKeys struct {
	Keys [][]byte `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
}

func (m *PageKeys) Reset()                    { *m = PageKeys{} }
func (m *PageKeys) String() string            { return proto.CompactTextString(m) }
func (*PageKeys) ProtoMessage()               {}
func (*PageKeys) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PageKeys) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// Page is a portion (possibly all) of an Entry document.
type Page struct {
	// ECDSA public key of the entry author
	AuthorPublicKey []byte `protobuf:"bytes,1,opt,name=author_public_key,json=authorPublicKey,proto3" json:"author_public_key,omitempty"`
	// index of Page within Entry contents
	Index uint32 `protobuf:"varint,2,opt,name=index" json:"index,omitempty"`
	// ciphertext of Page contents, encrypted using the 32-byte AES-256 key with the block cipher
	// initialized by the first 12 bytes of HMAC-256(IV seed, page index)
	Ciphertext []byte `protobuf:"bytes,3,opt,name=ciphertext,proto3" json:"ciphertext,omitempty"`
	// 32-byte MAC of ciphertext using the 32-byte Page ciphertext HMAC-256 key
	CiphertextMac []byte `protobuf:"bytes,4,opt,name=ciphertext_mac,json=ciphertextMac,proto3" json:"ciphertext_mac,omitempty"`
}

func (m *Page) Reset()                    { *m = Page{} }
func (m *Page) String() string            { return proto.CompactTextString(m) }
func (*Page) ProtoMessage()               {}
func (*Page) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Page) GetAuthorPublicKey() []byte {
	if m != nil {
		return m.AuthorPublicKey
	}
	return nil
}

func (m *Page) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Page) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *Page) GetCiphertextMac() []byte {
	if m != nil {
		return m.CiphertextMac
	}
	return nil
}

func init() {
	proto.RegisterType((*Document)(nil), "api.Document")
	proto.RegisterType((*Envelope)(nil), "api.Envelope")
	proto.RegisterType((*Entry)(nil), "api.Entry")
	proto.RegisterType((*Metadata)(nil), "api.Metadata")
	proto.RegisterType((*PageKeys)(nil), "api.PageKeys")
	proto.RegisterType((*Page)(nil), "api.Page")
}

func init() { proto.RegisterFile("libri/librarian/api/documents.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 467 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x93, 0xcb, 0x8b, 0x13, 0x41,
	0x10, 0xc6, 0x77, 0x5e, 0xcb, 0xa4, 0x92, 0xb8, 0x5a, 0xae, 0x38, 0x28, 0xae, 0x71, 0x44, 0x08,
	0x2a, 0x09, 0xac, 0x20, 0x22, 0xec, 0xc5, 0x07, 0x2c, 0x2c, 0x0b, 0x61, 0xf0, 0x3e, 0x74, 0x66,
	0x8a, 0xdd, 0xc6, 0xcc, 0x4c, 0xd3, 0xe9, 0x2c, 0x3b, 0x27, 0xaf, 0xde, 0xbc, 0xfb, 0xd7, 0x4a,
	0xd7, 0x3c, 0xc8, 0xc6, 0x78, 0xf0, 0x92, 0x74, 0xd7, 0xf7, 0xab, 0xae, 0xaa, 0xaf, 0x7b, 0xe0,
	0xe5, 0x4a, 0x2e, 0xb5, 0x9c, 0xdb, 0x5f, 0xa1, 0xa5, 0x28, 0xe7, 0x42, 0xc9, 0x79, 0x5e, 0x65,
	0x9b, 0x82, 0x4a, 0xb3, 0x9e, 0x29, 0x5d, 0x99, 0x0a, 0x3d, 0xa1, 0x64, 0xfc, 0xd3, 0x81, 0xf0,
	0x4b, 0x2b, 0xe0, 0x1b, 0x08, 0xa9, 0xbc, 0xa1, 0x55, 0xa5, 0x28, 0x72, 0x26, 0xce, 0x74, 0x78,
	0x3a, 0x9e, 0x09, 0x25, 0x67, 0x5f, 0xdb, 0xe0, 0xf9, 0x41, 0xd2, 0x03, 0x18, 0x43, 0x40, 0xa5,
	0xd1, 0x75, 0xe4, 0x32, 0x09, 0x2d, 0x69, 0x74, 0x7d, 0x7e, 0x90, 0x34, 0x12, 0x3e, 0x07, 0x5f,
	0x89, 0x2b, 0x8a, 0x3c, 0x46, 0x06, 0x8c, 0x2c, 0xc4, 0x95, 0x3d, 0x88, 0x85, 0x4f, 0x00, 0x61,
	0x56, 0x95, 0xc6, 0x76, 0x15, 0xff, 0x80, 0xb0, 0x2b, 0x84, 0x4f, 0x61, 0xc0, 0x27, 0xa4, 0xdf,
	0xa9, 0xe6, 0x56, 0x46, 0xb6, 0xb2, 0xd1, 0xf5, 0x05, 0xd5, 0xf8, 0x1a, 0x1e, 0x88, 0x8d, 0xb9,
	0xae, 0x74, 0xaa, 0x36, 0xcb, 0x95, 0xcc, 0x18, 0x72, 0x19, 0x3a, 0x6a, 0x84, 0x05, 0xc7, 0x5b,
	0x56, 0x93, 0xc8, 0xe9, 0x0e, 0xeb, 0x35, 0x6c, 0x23, 0xf4, 0x6c, 0xfc, 0xdb, 0x85, 0x80, 0x07,
	0xd8, 0x5f, 0xc1, 0xd9, 0x5f, 0xa1, 0x9b, 0xd1, 0xfd, 0xc7, 0x8c, 0xf8, 0x16, 0x06, 0xf6, 0xdf,
	0x9e, 0xb1, 0x6e, 0x9d, 0x18, 0xf7, 0xd4, 0x05, 0xd5, 0x6b, 0x6b, 0xab, 0x6a, 0xd7, 0xf8, 0x02,
	0x46, 0x99, 0x26, 0x61, 0x28, 0x4f, 0x8d, 0x2c, 0x28, 0xf2, 0x27, 0xce, 0xd4, 0x4b, 0x86, 0x6d,
	0xec, 0x9b, 0x2c, 0x08, 0xe7, 0xf0, 0xb0, 0x20, 0x23, 0x72, 0x61, 0x44, 0x9a, 0x49, 0x75, 0x4d,
	0xda, 0xd0, 0xad, 0x89, 0x02, 0xee, 0x0f, 0x3b, 0xe9, 0x73, 0xaf, 0xe0, 0x7b, 0x78, 0xbc, 0x27,
	0x21, 0x2d, 0x44, 0x16, 0x1d, 0x72, 0xd2, 0xa3, 0xbf, 0x93, 0x2e, 0x45, 0x76, 0xe7, 0x76, 0xec,
	0x43, 0xb9, 0x6c, 0x29, 0x3c, 0x03, 0x50, 0xba, 0x52, 0xa4, 0x8d, 0xa4, 0x75, 0xe4, 0x4c, 0xbc,
	0xe9, 0xf0, 0xf4, 0x19, 0xcf, 0xd4, 0x21, 0xb3, 0x45, 0xaf, 0xb3, 0xa5, 0xc9, 0x56, 0xc2, 0x93,
	0x33, 0x38, 0xda, 0x91, 0xf1, 0x3e, 0x78, 0x9d, 0xc7, 0x83, 0xc4, 0x2e, 0xf1, 0x18, 0x82, 0x1b,
	0xb1, 0xda, 0x50, 0x7b, 0xb3, 0xcd, 0xe6, 0xa3, 0xfb, 0xc1, 0x89, 0x4f, 0x20, 0xec, 0xac, 0x43,
	0x04, 0x9f, 0x7d, 0xb5, 0x3d, 0x8c, 0x12, 0x5e, 0xc7, 0xbf, 0x1c, 0xf0, 0x2d, 0xf0, 0x5f, 0xd7,
	0x78, 0x0c, 0x81, 0x2c, 0x73, 0xba, 0xe5, 0x72, 0xe3, 0xa4, 0xd9, 0xe0, 0x09, 0xc0, 0x96, 0xc3,
	0xcd, 0xbb, 0xd9, 0x8a, 0xe0, 0x2b, 0xb8, 0xb7, 0x63, 0xa8, 0xcf, 0xcc, 0x38, 0xdb, 0x36, 0x72,
	0x79, 0xc8, 0x5f, 0xdc, 0xbb, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x06, 0x51, 0x3f, 0xd7, 0x98,
	0x03, 0x00, 0x00,
}
